!function(){"use strict";const{Array:e,Object:t,Math:s,Error:n,Uint8Array:r,Uint16Array:a,Uint32Array:i,Int32Array:o,DataView:c,TextEncoder:l,crypto:h,postMessage:u,TransformStream:d,ReadableStream:p,WritableStream:f,CompressionStream:g,DecompressionStream:w}=globalThis,y=[];for(let e=0;256>e;e++){let t=e;for(let e=0;8>e;e++)1&t?t=t>>>1^3988292384:t>>>=1;y[e]=t}class m{constructor(e){this.crc=e||-1}append(e){let t=0|this.crc;for(let s=0,n=0|e.length;n>s;s++)t=t>>>8^y[255&(t^e[s])];this.crc=t}get(){return~this.crc}}class _ extends d{constructor(){super({start(){this.crc32=new m},transform(e){e&&this.crc32.append(e)},flush(e){const t=new r(4);new c(t.buffer).setUint32(0,this.crc32.get()),e.enqueue(t)}})}}const b={concat(e,t){if(0===e.length||0===t.length)return e.concat(t);const s=e[e.length-1],n=b.getPartial(s);return 32===n?e.concat(t):b._shiftRight(t,n,0|s,e.slice(0,e.length-1))},bitLength(e){const t=e.length;if(0===t)return 0;const s=e[t-1];return 32*(t-1)+b.getPartial(s)},clamp(e,t){if(32*e.length<t)return e;const n=(e=e.slice(0,s.ceil(t/32))).length;return t&=31,n>0&&t&&(e[n-1]=b.partial(t,e[n-1]&2147483648>>t-1,1)),e},partial:(e,t,s)=>32===e?t:(s?0|t:t<<32-e)+1099511627776*e,getPartial:e=>s.round(e/1099511627776)||32,_shiftRight(e,t,s,n){for(void 0===n&&(n=[]);t>=32;t-=32)n.push(s),s=0;if(0===t)return n.concat(e);for(let r=0;r<e.length;r++)n.push(s|e[r]>>>t),s=e[r]<<32-t;const r=e.length?e[e.length-1]:0,a=b.getPartial(r);return n.push(b.partial(t+a&31,t+a>32?s:n.pop(),1)),n}},v={bytes:{fromBits(e){const t=b.bitLength(e)/8,s=new r(t);let n;for(let r=0;t>r;r++)0==(3&r)&&(n=e[r/4]),s[r]=n>>>24,n<<=8;return s},toBits(e){const t=[];let s,n=0;for(s=0;s<e.length;s++)n=n<<8|e[s],3==(3&s)&&(t.push(n),n=0);return 3&s&&t.push(b.partial(8*(3&s),n)),t}}},k={sha1:function(e){e?(this._h=e._h.slice(0),this._buffer=e._buffer.slice(0),this._length=e._length):this.reset()}};k.sha1.prototype={blockSize:512,reset:function(){const e=this;return e._h=this._init.slice(0),e._buffer=[],e._length=0,e},update:function(e){const t=this;"string"==typeof e&&(e=v.utf8String.toBits(e));const s=t._buffer=b.concat(t._buffer,e),r=t._length,a=t._length=r+b.bitLength(e);if(a>9007199254740991)throw new n("Cannot hash more than 2^53 - 1 bits");const o=new i(s);let c=0;for(let e=t.blockSize+r-(t.blockSize+r&t.blockSize-1);a>=e;e+=t.blockSize)t._block(o.subarray(16*c,16*(c+1))),c+=1;return s.splice(0,16*c),t},finalize:function(){const e=this;let t=e._buffer;const n=e._h;t=b.concat(t,[b.partial(1,1)]);for(let e=t.length+2;15&e;e++)t.push(0);for(t.push(s.floor(e._length/4294967296)),t.push(0|e._length);t.length;)e._block(t.splice(0,16));return e.reset(),n},_init:[1732584193,4023233417,2562383102,271733878,3285377520],_key:[1518500249,1859775393,2400959708,3395469782],_f:(e,t,s,n)=>e>19?e>39?e>59?e>79?void 0:t^s^n:t&s|t&n|s&n:t^s^n:t&s|~t&n,_S:(e,t)=>t<<e|t>>>32-e,_block:function(t){const n=this,r=n._h,a=e(80);for(let e=0;16>e;e++)a[e]=t[e];let i=r[0],o=r[1],c=r[2],l=r[3],h=r[4];for(let e=0;79>=e;e++){16>e||(a[e]=n._S(1,a[e-3]^a[e-8]^a[e-14]^a[e-16]));const t=n._S(5,i)+n._f(e,o,c,l)+h+a[e]+n._key[s.floor(e/20)]|0;h=l,l=c,c=n._S(30,o),o=i,i=t}r[0]=r[0]+i|0,r[1]=r[1]+o|0,r[2]=r[2]+c|0,r[3]=r[3]+l|0,r[4]=r[4]+h|0}};const S={getRandomValues(e){const t=new i(e.buffer),n=e=>{let t=987654321;const n=4294967295;return()=>(t=36969*(65535&t)+(t>>16)&n,(((t<<16)+(e=18e3*(65535&e)+(e>>16)&n)&n)/4294967296+.5)*(s.random()>.5?1:-1))};for(let r,a=0;a<e.length;a+=4){const e=n(4294967296*(r||s.random()));r=987654071*e(),t[a/4]=4294967296*e()|0}return e}},C={importKey:e=>new C.hmacSha1(v.bytes.toBits(e)),pbkdf2(e,t,s,r){if(s=s||1e4,0>r||0>s)throw new n("invalid params to pbkdf2");const a=1+(r>>5)<<2;let i,o,l,h,u;const d=new ArrayBuffer(a),p=new c(d);let f=0;const g=b;for(t=v.bytes.toBits(t),u=1;(a||1)>f;u++){for(i=o=e.encrypt(g.concat(t,[u])),l=1;s>l;l++)for(o=e.encrypt(o),h=0;h<o.length;h++)i[h]^=o[h];for(l=0;(a||1)>f&&l<i.length;l++)p.setInt32(f,i[l]),f+=4}return d.slice(0,r/8)},hmacSha1:class{constructor(e){const t=this,s=t._hash=k.sha1,n=[[],[]],r=s.prototype.blockSize/32;t._baseHash=[new s,new s],e.length>r&&(e=s.hash(e));for(let t=0;r>t;t++)n[0][t]=909522486^e[t],n[1][t]=1549556828^e[t];t._baseHash[0].update(n[0]),t._baseHash[1].update(n[1]),t._resultHash=new s(t._baseHash[0])}reset(){const e=this;e._resultHash=new e._hash(e._baseHash[0]),e._updated=!1}update(e){this._updated=!0,this._resultHash.update(e)}digest(){const e=this,t=e._resultHash.finalize(),s=new e._hash(e._baseHash[1]).update(t).finalize();return e.reset(),s}encrypt(e){if(this._updated)throw new n("encrypt on already updated hmac called!");return this.update(e),this.digest(e)}}},z="Invalid pasword",I=16,B={name:"PBKDF2"},D=t.assign({hash:{name:"HMAC"}},B),R=t.assign({iterations:1e3,hash:{name:"SHA-1"}},B),T=["deriveBits"],V=[8,12,16],H=[16,24,32],q=10,K=[0,0,0,0],A=void 0!==h,P=A&&void 0!==h.subtle,W=v.bytes,x=class{constructor(e){const t=this;t._tables=[[[],[],[],[],[]],[[],[],[],[],[]]],t._tables[0][0][0]||t._precompute();const s=t._tables[0][4],r=t._tables[1],a=e.length;let i,o,c,l=1;if(4!==a&&6!==a&&8!==a)throw new n("invalid aes key size");for(t._key=[o=e.slice(0),c=[]],i=a;4*a+28>i;i++){let e=o[i-1];(i%a==0||8===a&&i%a==4)&&(e=s[e>>>24]<<24^s[e>>16&255]<<16^s[e>>8&255]<<8^s[255&e],i%a==0&&(e=e<<8^e>>>24^l<<24,l=l<<1^283*(l>>7))),o[i]=o[i-a]^e}for(let e=0;i;e++,i--){const t=o[3&e?i:i-4];c[e]=4>=i||4>e?t:r[0][s[t>>>24]]^r[1][s[t>>16&255]]^r[2][s[t>>8&255]]^r[3][s[255&t]]}}encrypt(e){return this._crypt(e,0)}decrypt(e){return this._crypt(e,1)}_precompute(){const e=this._tables[0],t=this._tables[1],s=e[4],n=t[4],r=[],a=[];let i,o,c,l;for(let e=0;256>e;e++)a[(r[e]=e<<1^283*(e>>7))^e]=e;for(let h=i=0;!s[h];h^=o||1,i=a[i]||1){let a=i^i<<1^i<<2^i<<3^i<<4;a=a>>8^255&a^99,s[h]=a,n[a]=h,l=r[c=r[o=r[h]]];let u=16843009*l^65537*c^257*o^16843008*h,d=257*r[a]^16843008*a;for(let s=0;4>s;s++)e[s][h]=d=d<<24^d>>>8,t[s][a]=u=u<<24^u>>>8}for(let s=0;5>s;s++)e[s]=e[s].slice(0),t[s]=t[s].slice(0)}_crypt(e,t){if(4!==e.length)throw new n("invalid aes block size");const s=this._key[t],r=s.length/4-2,a=[0,0,0,0],i=this._tables[t],o=i[0],c=i[1],l=i[2],h=i[3],u=i[4];let d,p,f,g=e[0]^s[0],w=e[t?3:1]^s[1],y=e[2]^s[2],m=e[t?1:3]^s[3],_=4;for(let e=0;r>e;e++)d=o[g>>>24]^c[w>>16&255]^l[y>>8&255]^h[255&m]^s[_],p=o[w>>>24]^c[y>>16&255]^l[m>>8&255]^h[255&g]^s[_+1],f=o[y>>>24]^c[m>>16&255]^l[g>>8&255]^h[255&w]^s[_+2],m=o[m>>>24]^c[g>>16&255]^l[w>>8&255]^h[255&y]^s[_+3],_+=4,g=d,w=p,y=f;for(let e=0;4>e;e++)a[t?3&-e:e]=u[g>>>24]<<24^u[w>>16&255]<<16^u[y>>8&255]<<8^u[255&m]^s[_++],d=g,g=w,w=y,y=m,m=d;return a}},U=class{constructor(e,t){this._prf=e,this._initIv=t,this._iv=t}reset(){this._iv=this._initIv}update(e){return this.calculate(this._prf,e,this._iv)}incWord(e){if(255==(e>>24&255)){let t=e>>16&255,s=e>>8&255,n=255&e;255===t?(t=0,255===s?(s=0,255===n?n=0:++n):++s):++t,e=0,e+=t<<16,e+=s<<8,e+=n}else e+=1<<24;return e}incCounter(e){0===(e[0]=this.incWord(e[0]))&&(e[1]=this.incWord(e[1]))}calculate(e,t,s){let n;if(!(n=t.length))return[];const r=b.bitLength(t);for(let r=0;n>r;r+=4){this.incCounter(s);const n=e.encrypt(s);t[r]^=n[0],t[r+1]^=n[1],t[r+2]^=n[2],t[r+3]^=n[3]}return b.clamp(t,r)}},G=C.hmacSha1;class L extends d{constructor(s,a,i){let o;super({start(){t.assign(this,{ready:new Promise((e=>this.resolveReady=e)),password:s,signed:a,strength:i-1,pendingInput:new r(0)})},async transform(t,s){if(t&&t.length){const a=this;if(a.password){const s=a.password;a.password=null;const r=F(t,0,V[a.strength]+2);await(async(e,t,s)=>{await j(e,s,F(t,0,V[e.strength]));const r=F(t,V[e.strength]),a=e.keys.passwordVerification;if(a[0]!=r[0]||a[1]!=r[1])throw new n(z)})(a,r,s),a.aesCtrGladman=new U(new x(a.keys.key),e.from(K)),a.hmac=new G(a.keys.authentication),t=F(t,V[a.strength]+2),a.resolveReady()}else await a.ready;const i=new r(t.length-q-(t.length-q)%I);s.enqueue(E(a,t,i,0,q,!0))}},async flush(e){const t=this;await t.ready;const s=t.pendingInput,n=F(s,0,s.length-q),a=F(s,s.length-q);let i=new r(0);if(n.length){const e=W.toBits(n);t.hmac.update(e);const s=t.aesCtrGladman.update(e);i=W.fromBits(s)}if(o.valid=!0,t.signed){const e=F(W.fromBits(t.hmac.digest()),0,q);for(let t=0;q>t;t++)e[t]!=a[t]&&(o.valid=!1)}e.enqueue(i)}}),o=this}}class M extends d{constructor(s,n){let a;super({start(){t.assign(this,{ready:new Promise((e=>this.resolveReady=e)),password:s,strength:n-1,pendingInput:new r(0)})},async transform(t,s){if(t&&t.length){const n=this;let a=new r(0);if(n.password){const t=n.password;n.password=null,a=await(async(e,t)=>{const s=(n=new r(V[e.strength]),A&&"function"==typeof h.getRandomValues?h.getRandomValues(n):S.getRandomValues(n));var n;return await j(e,t,s),O(s,e.keys.passwordVerification)})(n,t),n.aesCtrGladman=new U(new x(n.keys.key),e.from(K)),n.hmac=new G(n.keys.authentication),n.resolveReady()}else await n.ready;const i=new r(a.length+t.length-t.length%I);i.set(a,0),s.enqueue(E(n,t,i,a.length,0))}},async flush(e){const t=this;await t.ready;let s=new r(0);if(t.pendingInput.length){const e=t.aesCtrGladman.update(W.toBits(t.pendingInput));t.hmac.update(e),s=W.fromBits(e)}a.signature=W.fromBits(t.hmac.digest()).slice(0,q),e.enqueue(O(s,a.signature))}}),a=this}}function E(e,t,s,n,a,i){const o=t.length-a;let c;for(e.pendingInput.length&&(t=O(e.pendingInput,t),s=((e,t)=>{if(t&&t>e.length){const s=e;(e=new r(t)).set(s,0)}return e})(s,o-o%I)),c=0;o-I>=c;c+=I){const r=W.toBits(F(t,c,c+I));i&&e.hmac.update(r);const a=e.aesCtrGladman.update(r);i||e.hmac.update(a),s.set(W.fromBits(a),c+n)}return e.pendingInput=F(t,c),s}async function j(e,s,n){const a=(e=>{if(void 0===l){const t=new r((e=unescape(encodeURIComponent(e))).length);for(let s=0;s<t.length;s++)t[s]=e.charCodeAt(s);return t}return(new l).encode(e)})(s),i=await((e,t,s,n,r)=>A&&P&&"function"==typeof h.subtle.importKey?h.subtle.importKey("raw",t,s,!1,r):C.importKey(t))(0,a,D,0,T),o=await(async(e,t,s)=>A&&P&&"function"==typeof h.subtle.deriveBits?await h.subtle.deriveBits(e,t,s):C.pbkdf2(t,e.salt,R.iterations,s))(t.assign({salt:n},R),i,8*(2*H[e.strength]+2)),c=new r(o);e.keys={key:W.toBits(F(c,0,H[e.strength])),authentication:W.toBits(F(c,H[e.strength],2*H[e.strength])),passwordVerification:F(c,2*H[e.strength])}}function O(e,t){let s=e;return e.length+t.length&&(s=new r(e.length+t.length),s.set(e,0),s.set(t,e.length)),s}function F(e,t,s){return e.subarray(t,s)}class J extends d{constructor(e,s){let r;super({start(){t.assign(this,{password:e,passwordVerification:s}),Y(this,e)},transform(e,t){if(this.password){const t=Q(this,e.subarray(0,12));if(this.password=null,t[11]!=this.passwordVerification)throw new n(z);e=e.subarray(12)}t.enqueue(Q(this,e))},flush(){r.valid=!0}}),r=this}}class N extends d{constructor(e,s){super({start(){t.assign(this,{password:e,passwordVerification:s}),Y(this,e)},transform(e,t){if(e){let s,n;if(this.password){this.password=null;const t=h.getRandomValues(new r(12));t[11]=this.passwordVerification,s=new r(e.length+t.length),s.set(X(this,t),0),n=12}else s=new r(e.length),n=0;s.set(X(this,e),n),t.enqueue(s)}},flush(){}})}}function Q(e,t){const s=new r(t.length);for(let n=0;n<t.length;n++)s[n]=$(e)^t[n],Z(e,s[n]);return s}function X(e,t){const s=new r(t.length);for(let n=0;n<t.length;n++)s[n]=$(e)^t[n],Z(e,t[n]);return s}function Y(e,t){e.keys=[305419896,591751049,878082192],e.crcKey0=new m(e.keys[0]),e.crcKey2=new m(e.keys[2]);for(let s=0;s<t.length;s++)Z(e,t.charCodeAt(s))}function Z(e,t){e.crcKey0.append([t]),e.keys[0]=~e.crcKey0.get(),e.keys[1]=te(e.keys[1]+ee(e.keys[0])),e.keys[1]=te(s.imul(e.keys[1],134775813)+1),e.crcKey2.append([e.keys[1]>>>24]),e.keys[2]=~e.crcKey2.get()}function $(e){const t=2|e.keys[2];return ee(s.imul(t,1^t)>>>8)}function ee(e){return 255&e}function te(e){return 4294967295&e}class se extends d{constructor(e,t){super({start(){this.codec=new e(t)},transform(e,t){(e=this.codec.append(e))&&t.enqueue(e)},flush(e){const t=this.codec.flush();t&&e.enqueue(t)}})}}const ne="deflate",re="inflate",ae="Invalid signature",ie="data";class oe{constructor(e,{signature:s,password:n,signed:r,compressed:a,zipCrypto:i,passwordVerification:o,encryptionStrength:c,useCompressionStream:l},{chunkSize:h}){const u=this;u.start=async()=>{const d=!!n;if(t.assign(u,{signature:s,encrypted:d,signed:r,compressed:a,zipCrypto:i,stream:new p({async pull(e){const{value:t,done:s}=await u.pull();e.enqueue(t),(s||u.aborted)&&e.close()}})}),d&&(i?u.stream=u.stream.pipeThrough(new J(n,o)):(u.decryptStream=new L(n,r,c),u.stream=u.stream.pipeThrough(u.decryptStream))),a&&(u.stream=void 0!==l&&!l||void 0===w?u.stream.pipeThrough(new se(e,{chunkSize:h})):u.stream.pipeThrough(new w("deflate-raw"))),(!d||i)&&r){const e=u.stream.tee();u.stream=e[0],u.crc32Stream=e[1].pipeThrough(new _)}u.reader=u.stream.getReader(),await u.read()},u.abort=()=>u.aborted=!0}async read(){const e=this,{value:t,done:s}=await e.reader.read();if(t&&t.length&&e.ondata({value:{data:new r(t)}}),s){let t;if(e.encrypted&&!e.zipCrypto&&!e.decryptStream.valid)throw new n(ae);if((!e.encrypted||e.zipCrypto)&&e.signed){t=await e.crc32Stream.getReader().read();const s=new c(t.value.buffer);if(e.signature!=s.getUint32(0,!1))throw new n(ae)}e.ondata({value:{signature:t},done:s})}else await e.read()}}class ce{constructor(e,{encrypted:s,signed:n,compressed:r,level:a,zipCrypto:i,password:o,passwordVerification:c,encryptionStrength:l,useCompressionStream:h},{chunkSize:u}){const d=this;d.start=async()=>{if(t.assign(this,{encrypted:s,signed:n,compressed:r,zipCrypto:i,stream:new p({async pull(e){const{value:t,done:s}=await d.pull();e.enqueue(t),(s||d.aborted)&&e.close()}})}),(!s||i)&&n){const e=d.stream.tee();d.stream=e[0],d.crc32Stream=e[1].pipeThrough(new _({chunkSize:u}))}r&&(d.stream=void 0!==h&&!h||void 0===g?d.stream.pipeThrough(new se(e,{chunkSize:u,level:a})):d.stream.pipeThrough(new g("deflate-raw"))),s&&(i?d.stream=d.stream.pipeThrough(new N(o,c)):(d.encryptStream=new M(o,l),d.stream=d.stream.pipeThrough(d.encryptStream))),d.reader=d.stream.getReader(),await d.read()},d.abort=()=>d.aborted=!0}async read(){const e=this,{value:t,done:s}=await e.reader.read();if(t&&t.length&&e.ondata({value:{data:t}}),s){let t;e.encrypted&&!e.zipCrypto&&(t=e.encryptStream.signature),e.encrypted&&!e.zipCrypto||!e.signed||(t=await e.crc32Stream.getReader().read(),t=new c(t.value.buffer).getUint32(0)),e.ondata({value:{signature:t},done:s})}else await e.read()}}const le=new Map;let he,ue=0;function de(e){if(e.data){const t=e.data.value.data;if(t&&t.length)try{e.data.value.data=t.buffer,u(e,[e.data.value.data])}catch(t){u(e)}else u(e)}else u(e)}function pe(e,s,n){return class{constructor(a){const i=this;a.hasOwnProperty("level")&&void 0===a.level&&delete a.level,i.codec=new e(t.assign({},s,a)),n(i.codec,(e=>{if(i.pendingData){const t=i.pendingData;i.pendingData=new r(t.length+e.length),i.pendingData.set(t,0),i.pendingData.set(e,t.length)}else i.pendingData=new r(e)}))}append(e){return this.codec.push(e),a(this)}flush(){return this.codec.push(new r(0),!0),a(this)}};function a(e){if(e.pendingData){const t=e.pendingData;return e.pendingData=null,t}return new r(0)}}addEventListener("message",(async e=>{const t=e.data,s=t.type;try{if("start"==s&&(async e=>{try{e.scripts&&e.scripts.length&&importScripts.apply(void 0,e.scripts);const t=e.options;let s;self.initCodec&&self.initCodec(),t.codecType.startsWith(ne)?s=self.Deflate:t.codecType.startsWith(re)&&(s=self.Inflate),he=((e,t,s)=>t.codecType.startsWith(ne)?new ce(e,t,s):t.codecType.startsWith(re)?new oe(e,t,s):void 0)(s,t,e.config),he.ondata=e=>de({type:ie,data:e}),he.onerror=e=>u({error:{message:e.message,stack:e.stack}}),he.pull=()=>{const e=new Promise(((e,t)=>le.set(ue,{resolve:e,reject:t})));return de({type:"pull",messageId:ue}),ue++,e},await he.start()}catch(e){u({error:{message:e.message,stack:e.stack}})}})(t),s==ie){const{resolve:e}=le.get(t.messageId);le.delete(t.messageId),e({value:new r(t.data),done:t.done})}"abort"==s&&he.abort()}catch(e){u({error:{message:e.message,stack:e.stack}})}})),self.initCodec=()=>{const{Deflate:e,Inflate:t}=((e,t={},s)=>({Deflate:pe(e.Deflate,t.deflate,s),Inflate:pe(e.Inflate,t.inflate,s)}))(fflate,void 0,((e,t)=>e.ondata=t));self.Deflate=e,self.Inflate=t}}();
